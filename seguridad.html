<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Seguridad en la Raspberry-Pi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" type="text/css" href="estilo.css" />
  <link rel="stylesheet" type="text/css" href="fonts.css" />
  <script src="https://code.jquery.com/jquery-latest.js"></script>
  <script src="arriba.js"></script>
  <style>
    p {
      clear: both;
    }
  </style>
</head>
<body>
    <span class="ir-arriba icon-circle-up"></span>
<h1>Monitorización y Seguridad en la Raspberry-Pi</h1>
<hr />
<ul class="indice">
  <li><a href="#consejos">Consejos generales</a></li>
  <li><a href="#ssh">Mejorar la seguridad SSH</a></li>
  <li><a href="#proxy">Proxy Internet: cache web - SQUID</a></li>
  <li><a href="#monitor">Monitorización en la Raspberry-Pi</a></li>
  <ul><li><a href="#logwatch">Archivos Log: Logwatch</a></li>
      <li><a href="#munin">Monitorización del sistema: Munin</a></li>
  </ul>
  <li><a href="#seguridad">Seguridad en la Raspberry-Pi</a></li>
  <ul><li><a href="#fail2ban">Ataque por fuerza bruta: Fail2ban</a></li>
    <li><a href="#rootkit">Detección de rootkits: Rootkit Hunter</a></li>
    <li><a href="#audit">Auditoría de seguridad: Debsecan</a></li>
    <li><a href="#firewall">Cortafuegos: UFW</a></li>
</ul>
</ul>

<p id="consejos"><h3>Consejos Generales:</h3></p>

<p>La seguridad de la Raspberry Pi es importante. Las brechas en la seguridad pueden dejar la Raspberry Pi abierta a los piratas informáticos que luego pueden usarla con fines maliciosos. El nivel de seguridad que se necesita depende de cómo se vaya a usar la Raspberry Pi. Por ejemplo, si simplemente se está utilizando la Raspberry Pi en la red doméstica, detrás de un router que actua como un firewall, entonces, en principio ya es bastante seguro por defecto.</p>

<p>Sin embargo, si la Raspberry Pi va a estar directamente conectada a Internet, ya sea con una conexión directa (poco probable) o al permitir ciertos protocolos a través del firewall del router (por ejemplo, SSH), entonces se deben realizar algunos cambios de seguridad básicos. Incluso si se está protegido detrás de un firewall, es sensato tomarse la seguridad en serio. Los siguientes consejos describen algunas formas de mejorar la seguridad de la Raspberry Pi.</p>

<h4>1. Cambiar la contraseña predeterminada:</h4>

<p>Tal y como se explica en el <a href="anexo2.html#basica">anexo-2</a>, en el sistema operativo Raspbian viene el nombre de usuario <b>pi</b> y la contraseña <b>raspberry</b> predeterminados, por lo tanto, si se obtiene acceso a una Raspberry Pi, y estas configuraciones no se han cambiado, se tiene acceso de root a esa Raspberry Pi. Así que lo primero que se debe hacer es cambiar la contraseña. Esto puede hacerse a través de la aplicación raspi-config o desde la línea de comando, ejecutando <b>$ sudo raspi-config</b>, se  selecciona la opción 1 y se cambia la contraseña (de hecho, todo lo que raspi-config hace es ejecutar el comando <b>passwd</b> en la línea de comandos, que se puede hacer directamente desde la línea de comando, simplemente se escribe la nueva contraseña y se confirma).</p>
<p>Consejos para crear una contraseña robusta <a href="http://eduteka.icesi.edu.co/articulos/ContrasenhasRobustas" target="_blank">aquí</a>.</p>


<h4>2. Cambiar el nombre de usuario:</h4>

<p>Se puede hacer que la Raspberry Pi sea un poco más segura cambiando también el nombre de usuario. Todas las Raspberry vienen con el nombre de usuario predeterminado <b>pi</b>, por tanto si se cambia, se consigue un poco más de seguridad. Para agregar un nuevo usuario se ejecuta: <b>$ sudo adduser nacho</b>, se pedirá una nueva contraseña y el nuevo usuario tendrá el directorio de inicio en <b>/home/nacho</b>.</p>

<p>Para agregar el nuevo usuario al grupo sudo para otorgarles permisos de sudo: <b>$ sudo adduser nacho sudo</b>.</p>

<p>Una vez que se ha confirmado que la nueva cuenta está funcionando, se puede eliminar el usuario <b>pi</b>. Sin embargo, hay que tener en cuenta que con la distribución actual de Raspbian, hay algunos aspectos que requieren que el usuario <b>pi</b> esté presente. Si no se está seguro de si esto va a afectar, es mejor no eliminar al usuario <b>pi</b>. Desde la web oficial de la Raspberry-Pi informan que se está trabajando para reducir la dependencia del usuario <b>pi</b>. Para eliminar el usuario <b>pi</b>, se ejecuta: <b>$ sudo deluser pi</b>.</p>

<p>Este comando eliminará al usuario pi, pero no la carpeta <b>/home/pi</b>. Si es necesario, se puede usar el siguiente comando para eliminar la carpeta de inicio del usuario <b>pi</b> al mismo tiempo,<b>$ sudo deluser -remove-home pi</b>, pero hay que tener en cuenta que los datos de esta carpeta se borrarán de forma permanente, por lo tanto, hay que asegurarse de que los datos necesarios estén almacenados en otro lugar.</p>

<h4>3. Hacer que sudo pida contraseña:</h4>

<p>Al colocar <b>sudo</b> delante de un comando, se ejecuta como superusuario y, de forma predeterminada, no necesita una contraseña. En general, esto no es un problema. Sin embargo, si la Raspberry-Pi está expuesta a Internet y de alguna manera se consigue acceder a ella (tal vez mediante un exploit de página web, por ejemplo), el atacante podrá cambiar cosas que requieren credenciales de superusuario, a menos que se haya configurado <b>sudo</b> para requerir una contraseña. Para forzar que sudo requiera contraseña, hay que ejecutar la siguiente orden: <b>$ sudo nano /etc/sudoers.d/010_pi-nopasswd</b>, se edita el archivo y se cambia la entrada pi (o los nombres de usuario que tengan derechos de superusuario) a:</p>
<p> <b>pi ALL=(ALL) PASSWD: ALL</b></p>
<p align="left"><img src="images/sudo_pass1.png" title="hacer que sudo pida contraseña" alt="captura sudo pide contraseña" /></p>
<p align="left"><img src="images/sudo_pass2.png" title="hacer que sudo pida contraseña 2" alt="captura 2 sudo pide contraseña" /></p>
<p align="left"><img src="images/sudo_pass3.png" title="hacer que sudo pida contraseña 3" alt="captura 3 sudo pide contraseña" /></p>

<h4>4. Tener las últimas actualizaciones de seguridad:</h4>

<p>Esto puede ser tan simple como asegurarse de que la versión de Raspbian esté actualizada, ya que una distribución actualizada contiene las últimas actualizaciones de seguridad. Las instrucciones completas se pueden encontrar <a href="https://github.com/raspberrypi/documentation/blob/master/raspbian/updating.md" target="_blank">aquí</a>.</p>

<p>Si se está utilizando SSH para conectarse a la Raspberry Pi, puede valer la pena agregar una tarea periódica con <b>cron</b> que actualice específicamente el servidor ssh. Esta tarea garantizará que tenga las últimas actualizaciones de seguridad SSH, independientemente de su proceso normal de actualización. Se puede encontrar más información sobre la configuración de cron <a href="https://github.com/raspberrypi/documentation/blob/master/linux/usage/cron.md" target="_blank">aquí</a></p>

<p id="ssh"><h3>Mejorar la seguridad SSH:</h3></p>

<p>En principio, no se debe acceder físicamente a un servidor salvo por razones excepcionales (como la actualización o la reparación de hardware, por ejemplo). La mejor manera de gestionar un servidor es remotamente. Sin embargo, este acceso deber hacerse de manera segura, para garantizar que la comunicación no sea interceptada por terceros. El protocolo SSH es la solución para garantizar conexiones remotas seguras. SSH es un protocolo de comunicación que encripta los datos que se intercambian, y es virtualmente imposible romper la privacidad de la comunicación. El acrónimo ssh viene del inglés: Secure SHell. El protocolo ssh es muy versátil, tiene un software cliente que posibilita el acceso a la línea de comandos, permite la transferencia de archivos y la creación de túneles seguros con soporte de comunicación para otros protocolos.</p>

<p>SSH es una forma común de acceder a la Raspberry Pi de forma remota. De forma predeterminada, iniciar sesión con SSH requiere de nombre de usuario y contraseña, y hay formas de hacerlo más seguro, como por ejemplo usar autenticación basada en claves, mejorando la seguridad de nombre de usuario y contraseña. Lo más importante es asegurarse de tener una contraseña muy sólida, esto ayudará a evitar ataques de diccionario o similares.</p>

<h4><i>Editar y configurar sshd_config:</i></h4>

<p>Para editar la configuración del servidor SSH hay que editar el archivo sshd_config: <b>$ sudo nano /etc/ssh/sshd_config</b></p>

<p>Otro directorio que hay que tener muy en cuenta es el de hosts conocidos, ya que ahí es donde se configuran las claves criptográficas RSA/DSA. El directorio donde se encuentran los hosts conocidos y las claves públicas es el siguiente: <b>/home/usuario/.ssh/</b>. Este directorio por defecto está oculto (.ssh) y hay un directorio por cada usuario que haya en el sistema operativo y que se conecte a un servidor remoto.</p>

<p><b>1.</b> Cambiar el puerto por defecto del servidor SSH:</p>

<p>Por defecto los servidores SSH utilizan el puerto 22 para las conexiones. Es recomendable cambiar este número de puerto, para evitar que bots o cibercriminales puedan intentar iniciar sesión, aunque por sí solo esto no proporciona seguridad, sí se puede pasar desapercibido a los escaneos masivos desde Internet. Si por ejemplo se quiere usar el puerto 22445 se debe poner en el fichero de configuración lo siguiente: <b>Port 22445</b></p>

<p><b>2.</b> Bloquear el acceso root en las conexiones remotas:</p>

<p>Por defecto, cualquier usuario en el sistema operativo que tenga permisos de Shell, podrá iniciar sesión en el servidor. Además, se debe tener en cuenta que si se tiene activado el usuario root, también podrá conectarse al servidor de forma local o remota, evitando al atacante tener que “adivinar” el nombre de usuario. Por defecto, los bots siempre intentan atacar el puerto 22 y al usuario “root”. Desactivando al propio usuario root, y usando “sudo” para elevar a permisos de superusuario, se evita esto. Además, OpenSSH también permitirá deshabilitar el login del usuario root para dotar al sistema de mayor seguridad: <b>PermitRootLogin no</b></p>

<p>De esta manera las conexiones root quedarán bloqueadas evitando que usuarios no autorizados puedan realizar ataques de fuerza bruta contra el servidor SSH para adivinar los credenciales del usuario Root. También hay otras opciones en este apartado del archivo sshd_config, como por ejemplo “PermitRootLogin without-password” donde se permite autenticación pero no con usuario y contraseña, sino con claves criptográficas RSA.</p>
Configuraciones de seguridad adicionales

<p><b>3.</b> Existen otras configuraciones recomendadas para evitar las conexiones no deseadas al servidor SSH:</p>

  <ul><li><b>LoginGraceTime:</b> Establece el tiempo necesario para introducir la contraseña, evitando que el atacante tenga que “pensar mucho”.</li>
      <li><b>MaxAuthTries:</b> Número de intentos permitidos al introducir la contraseña antes de ser desconectados.</li>
      <li><b>MaxStartups:</b> Número de logins simultáneos desde una IP, para evitar que se pueda utilizar la fuerza bruta con varias sesiones a la vez.</li>
      <li><b>AllowUsers: </b> crear una lista blanca de usuario. Este parámetro permite configurar los usuarios que podrán conectarse. Una medida muy restrictiva pero a la vez muy segura ya que bloqueará todas las conexiones de los usuarios que no estén en el listado. Los usuarios que esten aquí podrán conectarse, y el resto no.</li>
      <li><b>DenyUsers:</b> Parecido al anterior, pero ahora se crea una lista negra. Los usuarios que esten aquí no podrán conectarse, y el resto sí.</li>
      <li><b>AllowGroups/DenyUsers:</b> Exactamente igual a lo anterior, pero en lugar de crear una lista blanca/negra de usuarios, es de grupos de usuarios.</li>
  </ul>

<p>Por ejemplo, un archivo de configuración de sshd_config sería el siguiente:</p>

<div class="codigo"><pre><code class="language-shell">
  <ul><li>Port 22445</li>
  <li>PermitRootLogin no</li>
  <li>LoginGraceTime 30</li>
  <li>MaxAuthTries 3</li>
  <li>MaxStartups 3</li>
  <li>AllowUsers nacho pi</li>
  <li>DenyUsers nacho2</li></ul>
</code></pre></div>
<p>Después de los cambios, se deberá reiniciar el servicio sshd utilizando <b>$ sudo systemctl restart ssh</b> o reiniciar para que los cambios surtan efecto.</p>

<h4><i>Autenticación en SSH:</i> usuario/contraseña y claves criptográficas.</h4>

<p>En este apartado se muestran los diferentes métodos de autenticación que hay disponibles en el servidor. Principalmente hay dos: <b>usuario y contraseña</b> (algo que sabemos), y también con <b>claves criptográficas</b> (algo que tenemos). No obstante, se puede dotar al sistema de una seguridad adicional, combinando estas autenticaciones con por ejemplo un <b>One Time Password</b> generado por una aplicación como <b>Google Authenticator</b> o <b>Latch OTP</b>. Además, también se puede dotar al sistema de <b>Latch</b>, para evitar que cualquier usuario inicie sesión si no está el “pestillo” abierto.</p>

<h4>1. Usuario y contraseña:</h4>

<p>Si se quiere habilitar el login en el servicio a través del usuario y contraseña del sistema, el archivo de configuración deberá tener esta sentencia: <b>PasswordAuthentication yes</b></p>

<p>De lo contrario, si se quiere impedir la autenticación a través de usuario/contraseña, y permitir únicamente las conexiones a través de claves criptográficas, se debe indicar no: <b>PasswordAuthentication no</b></p>

<p>Esta sentencia afecta a todos los usuarios del sistema. Para no quedarse sin acceso al servidor, hay que asegurarse de que la sentencia <b>PubkeyAuthentication</b> esté configurada a “yes”, para permitir el inicio de sesión con claves criptográficas.</p>

<p>Hay otra sentencia relacionada con esto llamada <b>ChallengeResponseAuthentication</b>, si se pone la configuración a “no”, no permitirá las conexiones donde se interactúe con el teclado, por lo que si por ejemplo hay configurado un One Time Password, no se podrá iniciar sesión en el sistema. Si únicamente se va a usar claves criptográficas, se puede poner a “no” sin problemas.</p>

<h4>2. Clave pública SSH:</h4>

<p>Los pares de claves son dos claves criptográficamente seguras. Una es privada y la otra es pública. Se pueden usar para autenticar un cliente en un servidor SSH (en este caso, el Raspberry Pi). El cliente genera dos claves, que están criptográficamente vinculadas entre sí. La clave privada nunca se debe compartir, pero la clave pública se puede compartir libremente. El servidor SSH usa una copia de la clave pública y, cuando se solicita un enlace, utiliza esta clave para enviar al cliente un mensaje de desafío, que el cliente cifrará con la clave privada. Si el servidor puede usar la clave pública para descifrar este mensaje de vuelta al mensaje de desafío original, entonces la identidad del cliente puede ser confirmada.</p>

<p>La generación del par de claves en Linux se realiza utilizando el comando <b>ssh-keygen</b> en el cliente, las claves se almacenan de forma predeterminada en la carpeta <b>.ssh</b> en el home del usuario directamente. La clave privada se llamará <b>id_rsa</b> y la clave pública asociada se llamará <b>id_rsa.pub</b>. La clave tendrá 2048 bits de longitud, romper el cifrado en una clave de esa longitud llevaría un tiempo extremadamente largo, por lo que es muy seguro. Se pueden crear claves más largas si la situación así lo exige. Hay que tener en cuenta que solo se debe hacer el proceso de generación una vez, si se repite, se sobrescribiran las claves generadas anteriormente. Todo lo que dependa de esas claves antiguas deberá actualizarse a las nuevas claves. Se pedirá una frase de contraseña durante la generación de claves, este es un nivel de seguridad adicional.</p>

<p>Para configurar el acceso con clave pública al servidor, se debe poner la sentencia siguiente a “yes”: <b>PubkeyAuthentication yes</b></p>

<p>Así es como se activa la configuración con clave pública SSH en el sistema, no obstante, aún hay algunos pasos que se deben hacer para poder conectar al servidor, y es pasar la clave pública al propio equipo. Para hacerlo, se debe permitir (de momento) la autenticación con usuario/contraseña, una vez se terminen todos los pasos se podrá denegar la autenticación con usuario y contraseña sin ningún problema.</p>

<p>Desde el ordenador desde el que se quiere conectar al servidor con claves criptográficas, se deben crear dichas claves y pasárselas al servidor. Para crear unas claves RSA de 4096 bits  hay que ejecutar en el cliente SSH la siguiente orden: <b>$ sudo ssh-keygen -t rsa -b 4096</b></p>

<p>El asistente de generación de estas claves, pregunta si se quiere guardar en <b>/home/usuario/.ssh/id_rsa</b>, se contesta que sí. Posteriormente se permitirá poner a la clave privada una contraseña de paso, de esta forma, si se pierde la llave privada no pasará nada porque no podrán conectarse, debido a que es necesario siempre introducir una contraseña de paso para poder realizar la conexión correctamente.</p>

<p>Una vez que se haya creado la clave pública y privada en el equipo local, se debe enviar la clave pública al servidor SSH donde se quiere conectar, <strong>ojo:</strong> la clave pública, con el siguiente comando: <b>$ sudo ssh-copy-id usuario@IP_servidor</b> (se agrega la nueva clave pública en el archivo de autorización llamado <b>authorized_keys</b>). También se pueden utilizar otros métodos, ejecutando <b>$ sudo cat id_rsa.pub &gt&gt ~/.ssh/authorized_keys</b>, o se puede editar el archivo <b>$ sudo nano ~/.ssh/authorized_keys</b> y pegar la clave. Se pueden tener varias entradas en el archivo <b>authorized_keys</b>, por lo que SSH puede admitir varios clientes.</p>

<p>Hay que tener en cuenta que el archivo authorized_keys necesita los permisos para que el sistema lo lea correctamente, ejecutando: <b>$ sudo chmod 644 ~/.ssh/authorized_keys</b></p>

<p>En la siguiente conexión, el usuario deberá confirmar que quiere añadir la identidad e introducir las credenciales de login para la cuenta que se quiere utilizar en ese servicio. Por este motivo es importante que en el servidor aún se mantenga la posibilidad de autenticar con usuario/contraseña. Una vez completado este proceso, ya tendría que ser posible hacer inicio de sesión en el equipo sin introducir la contraseña. Hay que acordarse de poner la directiva “PasswordAuthentication no” para no permitir accesos vía usuario y contraseña.</p>

<p id="proxy"><h3>Proxy Internet: cache web - SQUID</h3></p>

<h4>¿Qué es un proxy?</h4>

<p>Servidor cuyo objetivo es la centralización del tráfico entre Internet y una red local, y, de esa forma, cada uno de los ordenadores de la red local no tiene necesidad de disponer de una conexión directa a Internet. El servidor proxy también se utiliza para controlar los accesos no permitidos desde Internet hacia la red local. El proxy hace una transformación de las direcciones de entrada y salida. Cuando un ordenador de la red local hace una solicitud o petición web, el proxy la intercepta y la procesa. De esa forma oculta la dirección IP del ordenador real que hace la solicitud y en la petición aparece la IP del proxy.</p>

<p>Lo usual es que el ordenador que hace de servidor proxy tenga al menos dos interfaces de red: una conectada a la red local y la otra conectada a Internet a través de un dispositivo de electrónica de red adecuado. Todos los paquetes con origen en la red local llegan al servidor a través de la interfaz que atiende a la red local y son analizados antes de ser reenviados al exterior a través de la otra interfaz de red.</p>

<h4>¿Qué es un proxy-caché?</h4>

<p>Servidor situado entre la máquina del usuario y otra red, que normalmente sera Internet, que actúa como barrera de protección para separar las dos redes y como zona caché para acelerar el acceso a páginas web o poder restringir el acceso a contenidos. Almacena las páginas web de los servidores remotos en memorias intermedias para poder servirlas a los clientes bajo demanda.</p>

<p>El uso de un proxy web no introduce retardos en la obtención de la información, ya que si la página solicitada no está en la caché del proxy, se iniciará la búsqueda normal rápidamente, y si la página se encuentra en la memoria caché, la página se sirve con la velocidad de conexión de la red local, que siempre es superior a la de Internet.</p>

<h4>Funciones:</h4>

<p>En general un proxy puede realizar  las siguientes funciones:</p>

    <ul><li><b>Filtro de contenidos:</b> cuando el proxy puede seleccionar el tipo de contenidos accedidos por las estaciones de trabajo.</li>
        <li><b>Memoria caché de páginas web:</b> Un proxy es capaz de almacenar las páginas consultadas por los clientes en una memoria caché, con esto acelera las conexiones sucesivas y es capaz de servir dichas páginas si se pierde la conexión a Internet de manera momentánea.</li>
        <li><b>Servidor de direcciones IP:</b> Un proxy es capaz de asignar direcciones IP a las estaciones de trabajo utilizando un servidor DHCP.</li>
        <li><b>Cortafuegos:</b> Si el proxy es un intermediario que recoge conexiones y es capaz de interrumpirlas o continuarlas, es porque está funcionando como un cortafuegos del sistema.</li>
    </ul>

<p>Otras funciones importantes de los proxy son:</p>

    <ul><li>Permiten el acceso web a máquinas privadas (con una dirección IP privada) que no están conectadas directamente a Internet y que de esta forma sí pueden acceder a Internet.</li>
    <li>Controlan el acceso web aplicando reglas o normas. Por ejemplo, dependiendo de la máquina, la página solicitada, el día y/o hora de la solicitud, etc.</li>
    <li>Registran el tráfico web desde la red local hacia el exterior.</li>
    <li>Controlan el contenido web visitado y descargado para detectar la presencia de posibles ataques a través de virus, gusanos, troyanos, conejos, etc.</li>
    <li>Controlan la seguridad de la red local ante posibles ataques, intrusiones en el sistema, etc.</li>
    </ul>

<p>Además de la función de intermediario entre una red local e Internet y agilizar las conexiones mediante la caché, los proxy disponen de otras funcionalidades directamente relacionadas con temas de seguridad. Entre ellas:</p>

    <ul><li>Autenticación de usuarios: son capaces de gestionar sesiones de usuario, lo que les da un valor añadido en cuanto a seguridad.</li>
        <li>Filtrado del tráfico: son capaces de realizar un filtrado del tráfico de paquetes, pudiendo trabajar ya con dominios.</li>
        <li>Creación de ficheros log: permiten la creación y gestión de los logs generados por la herramienta utilizada como proxy.</li>
    </ul>

<h4><i>Instalación de un servidor proxy-cache:</i> <i>SQUID</i></h4>

<p>El servidor proxy de libre distribución más usado es <a href="http://www.squid-cache.org/" target="_blank">Squid</a>, basado en software libre GNU/Linux, aunque está disponible en varias plataformas, se puede encontrar una versión para windows <a href="http://wiki.squid-cache.org/SquidFaq/BinaryPackages" target="_blank">aquí</a>.</p>

<p>El primer paso es instalar el paquete mediante el comando: <b>$ sudo apt-get install squid</b></p>
<p>Al instalar la herramienta se generan una serie de archivos y directorios:</p>

<ul><li><b>/usr/sbin/:</b> contiene archivos ejecutables.</li>
    <li><b>/var/run/squid.pid</b>: archivo que contiene el PID (Process Identificator) del proceso squid.</li>
    <li><b>/var/log/squid/:</b> Directorio que almacena los archivos de logs de Squid.</li>
    <li><b>/var/spool/squid/:</b> Directorio que contiene la caché propiamente.</li>
    <li><b>/etc/squid/squid.conf</b> :Archivo de configuración de Squid.</li>
    <li><b>/usr/lib/squid/:</b> Complementos, autenticación,..</li>
    <li><b>/usr/share/doc/squid/:</b> Documentación de la herramienta Squid.</li>
</ul>

 <p>El archivo de configuración de Squid es <b>/etc/squid/squid.conf</b>, pero es enorme con más de mil lineas de código, por lo tanto se recomienda hacer una copia de seguridad del original y trabajar con una copia adecuada a las necesidades de cada usuario, ejecutando: <b>$ sudo cp /etc/squid/squid.conf /etc/squid.conf.bak</b></p>

<p>Una configuración básica debe de incluir, al menos, los siguientes parámetros:</p>

<ul>
    <li><b>cache_effective_user / group</b> Establece el usuario y grupo para Squid. Por problemas de seguridad es preferible que Squid y sus procesos asociados se         ejecuten como usuario y grupo proxy. Este usuario y grupo proxy tienen unas características especiales que no tienen ni el administrador (root) ni otros usuarios. En concreto proxy es un usuario que no tiene shell (no se puede conectar al sistema), tiene unos permisos limitados a su área de acción y debe ser el propietario del directorio caché y del directorio de logs.</li>
    <li><b>http_port</b> Establece el puerto de escucha para Squid. Por defecto Squid atiende las peticiones de los clientes por el puerto 3128. Pero también se podría utilizar, por ejemplo, el puerto 8080. Se puede cambiar el puerto pero es importante tener en cuenta que éste no debe ser utilizado por ningún otro servicio. Es posible asociar el servicio Squid a una determinada IP, que sería la que conecta con la red local. En ese caso la sintaxis es: http_port 192.168.112.1:3128 (siendo 192.168.1.1 la IP de la tj de red por donde escucha el servidor proxy.)</li>
    <li><b>cache_mem</b> Establece la cantidad de memoria RAM dedicada al almacenamiento de los bloques de la caché más solicitados. En la medida que se aumenta la cantidad de memoria física de la máquina, aumentará el rendimiento de Squid. La cantidad de RAM también depende de la cantidad de espacio en disco dedicado a la caché.</li>
    <li><b>cache_dir</b> Establece la localización y el tamaño de la caché en disco duro. Por defecto son 100MB. Se puede especificar el nº de subdirectorios y el nº de niveles posibles dentro de cada subdirectorio. Por ejemplo: <b>cache_dir ufs /var/spool/squid/ 500 16 256</b>, indica una caché en disco de 500MB, con 16 subdirectorios, cada uno de ellos con 256 niveles. UFS (Unix File System) es un sistema de archivos utilizado por muchos sistemas operativos Unix y es el formato original de Squid.</li>
    <li><b>visible_hostname</b> Establece el nombre del servidor. Se puede saber cuál es mediante el comando <b>hostname</b>. Si no se especifica el hostname de nuestra Raspberry-Pi puede que Squid no sea capaz de determinarlo automáticamente, causando así que el programa falle.</li>
</ul>

<p><b>acl</b>. Lista de control del acceso, el parámetro ACL permite:</p>

    <ul><li>Proteger al servidor proxy-caché de conexiones externas, evitando, de esa forma, que se conecten clientes desconocidos que podrían saturar la conexión con el exterior.</li>
    <li>Proteger a los clientes de accesos a puertos peligrosos actuando como cortafuegos contra posibles ataques desde la web.</li>
    <li>Establecer una jerarquía de cachés.</li>
    <li>Establecer la red como conjunto de trabajo o, por el contrario, como máquinas individuales.</li></ul>

<p>A continuación, a cada <b>ACL</b> creada se le hace corresponder una <b>Regla de Control de Acceso (http_access)</b> que es la que permite o deniega las acciones definidas en la ACL. La sintaxis es variable. Estos son algunos de los formatos más utilizados:</p>

<ul><li>acl [nombre_lista] src [componentes_lista]</li>
<li>acl [nombre_lista] time marco_horario</li>
<li>acl [nombre_lista] srcdomain/dstdomain domain</li>
<li>acl [nombre_lista] url_regex patron</li>
<li>acl [nombre_lista] maxconn limite</li></ul>

<p>donde:</p>

        <ul><li>nombre_lista: es el nombre que se le asigna a la ACL.</li>
        <li>src: hace referencia al origen, es decir, la dirección IP de un cliente.</li>
        <li>[componentes_lista]: puede indicar direcciones IP de redes con la máscara de red, o archivos cuyo contenido sean las direcciones IP.</li>
        <li>time: permite/deniega las conexiones dentro de una franja horaria, donde marco_horario sigue unas reglas de construcción particular.</li>
        <li>srcdomain/dstdomain: establece permisos sobre dominios web origen y destino.</li>
        <li>url_regex: permite definir ACLs que identifican sitios web dependiendo de que la URL contenga ciertos caracteres o palabras. Es decir, identifica una url que cumple una expresión regular o patrón. Con la opción -i ignora la diferencia entre mayúscula y minúscula (ignorecase).</li>
        <li>maxconn: establece un nº máximo de conexiones por IP.</li></ul>

<p><b>http_access</b>. Regla de control de acceso: La regla de control de acceso indica si se permite o deniega el acceso a Squid para hacer peticiones HTTP. Actúa siempre sobre una lista de control de acceso permitiendo o denegando la situación definida en ella. La sintaxis es: <b>http_access [ deny / allow ] [ lista_control_acceso ...]</b></p>

<p><b>Logs</b>. Registro de logs: Squid utiliza diferentes archivos para realizar el registro de actividad:</p>

<ul><li><b>access.log:</b> almacena peticiones hechas al proxy. Del análisis de su contenido se pueden obtener estadísticas.</li>
<li><b>cache.log:</b> almacena información general de funcionamiento de la caché, errores, etc.</li></ul>

<p>Un ejemplo básico del archivo de configuración puede ser el siguiente:</p>
<div class="codigo"><pre><code class="language-shell">
    <ul><li>cache_effective_user proxy</li>
    <li>cache_effective_group proxy</li>
    <li>http_port 3128</li>
    <li>cache_mem 500 MB</li>
    <li>cache_dir ufs /var/spool/squid/ 500 16 256</li>
    <li>visible_hostname nombreservidor</li>
    <li>access_log /var/log/squid/access.log squid</li>
   <li>cache_log /var/log/squid/cache.log</li>
  </ul>
</code></pre></div>

<p><b>Arranque y parada de Squid.</b> Al instalar squid queda ejecutandose. Ahora se ha crear la estructura necesaria para la cache del servicio. Esto hay que hacerlo a squid parado. Por otra parte hay que activar en el archivo de configuración la directiva que especifica donde esta ubicada la cache y su tamaño. Para crear la cache ejecutar el siguiente comando sólo la primera vez: <b>$ sudo /usr/sbin/squid -z</b>. La opción -z crea los directorios de la caché.</p>

<p>Siempre que se hagan modificaciones en el archivo de configuración se debe ejecutar la sigiente orden para validar la configuración de Squid, no debe dar ningún error al ejecutar la orden:<b>$ sudo squid -k parse</b>.Si no se ejecuta correctamente hay que comprobar los permisos de todos los directorios de caché y de logs dados en el archivo de configuración.</p>

<p>A continuación arrancar el servicio utilizando la orden siguiente:<b>$ sudo service squid start </b> (ó $ sudo systemctl start squid).</p>

<p>Si se necesita reiniciar para probar cambios hechos en la configuración, ejecutar:<b>$ sudo service squid restart</b> (ó $ sudo systemctl restart squid). Asimismo se puede comprobar si el servicio está iniciado o detenido con la orden:<b>$ sudo service squid status</b></p>

<p>Se puede comprobar que squid se esta ejecutando y escuchando peticiones en el puerto 3128 con la orden:<b> $ sudo netstat -atunp | grep squid</b></p>

<p><b>Resumen capturas pasos de instalación y puesta en marcha de SQUID</b></p>
<p align="left"><img src="images/squid_install.png" title="instalación squid" alt="captura instalación squid" /></p>
<p align="left"><img src="images/squid_bak.png" title="backup del archivo de configuración de squid" alt="captura backup archivo configuración squid" /></p>
<p align="left"><img src="images/squid_status.png" title="estado squid" alt="captura estado squid" /></p>
<p align="left"><img src="images/squid_conf.png" title="ejemplo archivo de configuración squid.conf" alt="capturaejemplo archivo configuración squid.conf" /></p>
<p align="left"><img src="images/squid_stop.png" title="parada de squid" alt="captura parada de squid" /></p>
<p align="left"><img src="images/squid_zparse.png" title="creación cache squid" alt="captura creación cache squid" /></p>


<p id="monitor"><h3>Monitorización en la Raspberry-Pi</h3></p>

<p><cite>No basta con que el servidor esté correctamente instalado y configurado. También es imperativo que pueda ser controlado y supervisado.</cite></p>

<p id="logwatch"><h4><i>Archivos log:</i></h4> Todos los procesos que se ejecutan en el servidor generan un registro de ocurrencias detallado. Estos registros deben ser objeto de un análisis cuidadoso, para verificar el funcionamiento correcto del sistema o detectar errores puntuales.</p>
<p>Una tarea fundamental cuando se administran servidores, es la monitorización de logs. Esta tarea puede resultar especialmente engorrosa cuando hay que administrar muchos servidores, o simplemente porque no se dispone suficiente tiempo para ello. Para hacer esta tarea un poco menos pesada se pueden utilizar herramientas como <em>logwatch</em>, con la que se obtiene una visión global de lo que ha estado pasando en el sistema durante un periodo de tiempo determinado.</p>

<p><h4>Instalación y configuración de Logwatch:</h4> El primer paso será instalar el paquete y ejecutarlo con permisos de sudo.</p>

<p align="left"><img src="images/logwatch_install.png" title="Instalación Logwatch" alt="captura instalación Logwatch" /></p>
<p align="left"><img src="images/logwatch_ejec.png" title="ejecución Logwatch" alt="captura ejecución Logwatch" /></p>

<p>El programa muestra una gran cantidad de información (en función de la cantidad de servicios que haya escuchando y de la cantidad de logs que se esten generando) en texto plano por la salida estándar. Los parámetros por defecto se pueden consultar en <b>/usr/share/logwatch/default.conf/logwatch.conf</b>.Se puede modificar este comportamiento por defecto de dos maneras:</p>

    <ol><li>Creando y modificando el archivo <b>/etc/logwatch/conf/logwatch.conf</b> añadiendo los parámetros deseados, que pueden ser consultados en el archivo <b>/usr/share/logwatch/default.conf/logwatch.conf</b>.</li>
    <li>Invocando el programa con los parámetros que se desee, que pueden ser consultados abriendo la página man correspondiente al programa.</li>
    </ol>

<p>Las opciones que probablemente sean susceptibles de ser modificadas a gusto del usuario serán las siguientes:</p>

    <ul><li><b>Output:</b> Indica por donde se quiere ver el reporte. Las opciones son bastante autoexplicativas: stdout | mail | file.</li>
    <li><b>Format:</b> El formato del texto mostrado en el reporte. Estos pueden ser: text | html.</li>
    <li><b>Mailto:</b> Correo al que enviar el reporte.</li>
    <li><b>Range:</b> Rango de tiempo que se analizará en los logs (all | today | yesterday).</li>
    <li><b>Detail:</b> Cantidad de detalle del reporte, siendo posibles: Low (o 0) | Med (o 5) | High (o 10).</li>
    <li><b>Service:</b> La opción service corresponde a una serie de scripts en perl que trae la aplicación incorporada. Se pueden listar todos consultando el contenido de la carpeta /usr/share/logwatch/scripts/services/, y si se tienen conocimientos de perl y se quiere modificar alguno de los scripts, se puede hacer sin problemas.</li>
    </ul>

<p id="munin"><h4><i>Monitorización del sistema:</i></h4> Algunas veces, es importante tener un pánel de informaciones donde, de forma rápida, sea posible verificar los parámetros del servidor, desde el uso de memoria, la carga del procesador, pasando por el estado de varios servicios, el espacio disponible en el disco, etc. La aplicación de monitorización <em>munin</em> ofrece esta perspectiva global de inmediato.</p>

<h4>Instalación y configuración de <a href="http://munin-monitoring.org/" target="_blank">Munin</a>:</h4>

<p>La herramienta <em>Munin</em> permite monitorizar diversos parámetros de uno o varios sistemas, por ejemplo, el estado y carga de los servicios, temperaturas, espacio en disco, etc. munin funciona según una arquitectura cliente-servidor, en que un sistema servidor recoge y organiza datos recibidos de varios sistemas clientes. Para monitorizar sólo un servidor, debe instalarse y configurarse los paquetes cliente y servidor en el mismo sistema. Las siguientes órdenes instalan ambos paquetes. </p>

<p><b>$ sudo apt-get install munin</b> (para el servidor ya incluye munin-node).</p>
<p><b>$ sudo apt-get install munin-node munin-plugins-core munin-plugins-extra</b> (para el cliente con algunos extras)</p>

<p><b>Ficheros de configuración:</b> Munin cuenta con varios ficheros y directorios que hay que conocer:</p>

<ul><li> <b>/etc/munin/munin.conf</b> Es el fichero de configuración general y, más concretamente, donde se configura el lado servidor de 	munin.  En este fichero se especifican los directorios a emplear y la configuración de las diferentes máquinas. Debe estar configurado en el servidor.</li>
<li> <b>/etc/munin/munin-node.conf</b> El fichero de configuración del nodo. Munin ve a cada equipo que monitoriza como el nodo de una red y mediante este fichero se especifica la configuración. Debe existir en cada equipo.</li>
<li> <b>/etc/munin/plugins/</b> Es el directorio donde munin lee los plugins a emplear.  Éstos son simples enlaces al directorio real de los plugins  (/var/lib/munin/plugins/) y se pueden añadir y quitar de la manera más simple, creando o borrando un enlace.</li>
<li> <b>/var/www/munin/</b> Directorio donde se vuelca por defecto el código HTML generado con los informes. Se puede cambiar en munin.conf.  Debe pertenecer al usuario y grupos munin.</li>
<li> <b>/var/lib/munin/</b> Directorio donde se guardan todos los datos de los diferentes nodos y con los que se generan las gráficas.</li>
<li> <b>/var/log/munin/</b> Directorio de registros del sistema o logs. En las configuraciones de red es interesante el fichero munin-nodes.log, que detalla la información enviada y transmitida desde el nodo.</li>
<li> <b>/etc/cron.d/munin</b> Fichero del cron que se ejecuta cada cinco minutos y que actualiza los datos del equipo en la base de datos de munin.</li>
<li> <b>/etc/cron.d/munin-node</b> Fichero del cron que se ejecuta cada cinco minutos y que actualiza los datos de los nodos que estén dados de alta.</li>
<li> <b>/etc/init.d/munin-node</b> Script para reiniciar la solicitud de información a los nodos.</li>
</ul>

<p><b>Configuración cliente:</b> La configuración del sistema cliente consiste en añadir la dirección del servidor, a la lista de direcciones que pueden establecer conexión con el cliente. La dirección debe añadirse en formato de expresión regular. En este caso, como el cliente y el servidor es lo mismo, es suficiente añadir la dirección 127.0.0.1. Esta configuración debe efectuarse en el archivo /etc/munin/munin-node.conf:</p>

<p><b>Servidor:</b> En el servidor deben añadirse a la configuración las direcciones de los clientes a contactar, lo que puede hacerse en el archivo /etc/munin/munin.conf:</p>

<hr />
<p class="mclibre">
  Esta página forma parte del proyecto <a href="https://nacholoop.github.io/enigma/"><cite>Mini servidor para prácticas ASIR</cite></a> por <cite>Nacho López Espert</cite>
</p>
</body>
</html>
